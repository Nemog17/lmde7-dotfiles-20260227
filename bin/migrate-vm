#!/bin/bash
set -eo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

msg()  { echo -e "${GREEN}[✓]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
err()  { echo -e "${RED}[✗]${NC} $1"; exit 1; }

# Detecta la distro
detect_distro() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        case "$ID" in
            fedora)              echo "fedora" ;;
            debian)              echo "debian" ;;
            ubuntu|linuxmint|pop) echo "ubuntu" ;;
            arch|manjaro|endeavouros) echo "arch" ;;
            opensuse*|sles)      echo "opensuse" ;;
            rhel|centos|rocky|alma) echo "rhel" ;;
            void)                echo "void" ;;
            nixos)               echo "nixos" ;;
            *)                   echo "desconocida" ;;
        esac
    else
        echo "desconocida"
    fi
}

# Instala los paquetes necesarios para GNOME Boxes segun la distro
install_deps() {
    local distro
    distro=$(detect_distro)

    echo -e "${BOLD}Distro detectada: $distro${NC}"
    echo ""

    local missing=()

    # Verificar cada dependencia
    [[ -e /dev/kvm ]] || missing+=("kvm")
    command -v qemu-system-x86_64 &>/dev/null || missing+=("qemu")
    command -v virsh &>/dev/null || missing+=("libvirt")
    command -v gnome-boxes &>/dev/null || dpkg -l gnome-boxes &>/dev/null 2>&1 || rpm -q gnome-boxes &>/dev/null 2>&1 || missing+=("gnome-boxes")

    # Verificar OVMF (UEFI)
    local ovmf_found=false
    for path in \
        /usr/share/OVMF/OVMF_CODE_4M.ms.fd \
        /usr/share/edk2/ovmf/OVMF_CODE.secboot.fd \
        /usr/share/edk2/x64/OVMF_CODE.secboot.fd \
        /usr/share/qemu/OVMF_CODE_4M.ms.fd \
        /usr/share/OVMF/x64/OVMF_CODE.secboot.4m.fd; do
        [[ -f "$path" ]] && { ovmf_found=true; break; }
    done
    $ovmf_found || missing+=("ovmf")

    # Verificar swtpm (TPM emulado, necesario para Windows 11)
    command -v swtpm &>/dev/null || missing+=("swtpm")

    if [[ ${#missing[@]} -eq 0 ]]; then
        msg "Todas las dependencias estan instaladas"
        return 0
    fi

    warn "Faltan: ${missing[*]}"
    echo ""

    # Armar comando de instalacion segun distro
    local install_cmd=""
    local pkgs=""

    case "$distro" in
        fedora)
            install_cmd="sudo dnf install -y"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" @virtualization" ;;
                    qemu)        pkgs+=" qemu-kvm" ;;
                    libvirt)     pkgs+=" libvirt libvirt-daemon-kvm" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" edk2-ovmf" ;;
                    swtpm)       pkgs+=" swtpm swtpm-tools" ;;
                esac
            done
            ;;
        debian)
            install_cmd="sudo apt install -y"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" qemu-kvm" ;;
                    qemu)        pkgs+=" qemu-system-x86" ;;
                    libvirt)     pkgs+=" libvirt-daemon-system libvirt-clients" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" ovmf" ;;
                    swtpm)       pkgs+=" swtpm swtpm-tools" ;;
                esac
            done
            ;;
        ubuntu)
            install_cmd="sudo apt install -y"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" qemu-kvm" ;;
                    qemu)        pkgs+=" qemu-system-x86" ;;
                    libvirt)     pkgs+=" libvirt-daemon-system libvirt-clients" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" ovmf" ;;
                    swtpm)       pkgs+=" swtpm swtpm-tools" ;;
                esac
            done
            ;;
        arch)
            install_cmd="sudo pacman -S --noconfirm"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" qemu-full" ;;
                    qemu)        pkgs+=" qemu-full" ;;
                    libvirt)     pkgs+=" libvirt virt-manager dnsmasq" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" edk2-ovmf" ;;
                    swtpm)       pkgs+=" swtpm" ;;
                esac
            done
            ;;
        opensuse)
            install_cmd="sudo zypper install -y"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" qemu-kvm" ;;
                    qemu)        pkgs+=" qemu-x86" ;;
                    libvirt)     pkgs+=" libvirt libvirt-client" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" qemu-ovmf-x86_64" ;;
                    swtpm)       pkgs+=" swtpm" ;;
                esac
            done
            ;;
        rhel)
            install_cmd="sudo dnf install -y"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" qemu-kvm" ;;
                    qemu)        pkgs+=" qemu-kvm" ;;
                    libvirt)     pkgs+=" libvirt libvirt-client" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" edk2-ovmf" ;;
                    swtpm)       pkgs+=" swtpm swtpm-tools" ;;
                esac
            done
            ;;
        void)
            install_cmd="sudo xbps-install -Sy"
            pkgs=""
            for dep in "${missing[@]}"; do
                case "$dep" in
                    kvm)         pkgs+=" qemu" ;;
                    qemu)        pkgs+=" qemu" ;;
                    libvirt)     pkgs+=" libvirt" ;;
                    gnome-boxes) pkgs+=" gnome-boxes" ;;
                    ovmf)        pkgs+=" OVMF" ;;
                    swtpm)       pkgs+=" swtpm" ;;
                esac
            done
            ;;
        *)
            echo ""
            err "Distro no soportada. Instala manualmente: qemu-kvm libvirt gnome-boxes ovmf swtpm"
            ;;
    esac

    # Eliminar duplicados
    pkgs=$(echo "$pkgs" | tr ' ' '\n' | sort -u | tr '\n' ' ')

    echo -e "  Se instalara: ${BOLD}$pkgs${NC}"
    echo ""
    read -rp "  Instalar? [S/n]: " resp
    [[ "$resp" =~ ^[nN]$ ]] && err "Instalacion cancelada"

    echo ""
    $install_cmd $pkgs

    # Habilitar y arrancar libvirtd si es necesario
    if command -v systemctl &>/dev/null; then
        sudo systemctl enable --now libvirtd 2>/dev/null || true
    fi

    # Agregar usuario al grupo libvirt si no esta
    if ! groups | grep -q libvirt; then
        sudo usermod -aG libvirt "$(whoami)" 2>/dev/null || true
        warn "Se agrego tu usuario al grupo 'libvirt'. Cierra sesion y vuelve a entrar para que tome efecto."
    fi

    echo ""
    msg "Dependencias instaladas"
}

usage() {
    echo "Uso: $0 <comando> [opciones]"
    echo ""
    echo "Comandos:"
    echo "  export DESTINO     Muestra las VMs y te deja elegir cuales exportar"
    echo "  import ORIGEN      Muestra las VMs exportadas y te deja elegir cuales importar"
    echo "  setup              Solo verifica e instala dependencias (sin importar VMs)"
    echo ""
    echo "Ejemplos:"
    echo "  $0 export /media/usuario/usb"
    echo "  $0 import /media/usuario/usb"
    echo "  $0 setup"
    echo ""
    echo "Distros soportadas: Fedora, Debian, Ubuntu/Mint/Pop, Arch/Manjaro,"
    echo "                     openSUSE, RHEL/CentOS/Rocky/Alma, Void"
    exit 1
}

# Detecta si una VM esta en modo sistema o sesion
detect_connection() {
    local vm_name="$1"
    if virsh -c qemu:///session dominfo "$vm_name" &>/dev/null; then
        echo "qemu:///session"
    elif sudo virsh -c qemu:///system dominfo "$vm_name" &>/dev/null; then
        echo "qemu:///system"
    else
        echo ""
    fi
}

# Recopila todas las VMs del sistema
gather_all_vms() {
    local -n result=$1
    result=()

    # Sesion de usuario
    local session_vms
    session_vms=$(virsh -c qemu:///session list --all --name 2>/dev/null | grep -v '^$' || true)
    if [[ -n "$session_vms" ]]; then
        while IFS= read -r vm; do
            local state
            state=$(virsh -c qemu:///session domstate "$vm" 2>/dev/null || echo "?")
            result+=("$vm|sesion|$state")
        done <<< "$session_vms"
    fi

    # Sistema
    local system_vms
    system_vms=$(sudo virsh -c qemu:///system list --all --name 2>/dev/null | grep -v '^$' || true)
    if [[ -n "$system_vms" ]]; then
        while IFS= read -r vm; do
            local state
            state=$(sudo virsh -c qemu:///system domstate "$vm" 2>/dev/null || echo "?")
            result+=("$vm|sistema|$state")
        done <<< "$system_vms"
    fi
}

# Menu interactivo de seleccion
select_vms() {
    local -n items=$1
    local -n selected=$2
    local count=${#items[@]}

    [[ $count -gt 0 ]] || err "No se encontraron VMs"

    # Inicializar seleccion (todo deseleccionado)
    local checks=()
    for ((i=0; i<count; i++)); do
        checks+=("off")
    done

    while true; do
        clear
        echo ""
        echo -e "${BOLD}=== Selecciona las VMs ===${NC}"
        echo ""
        echo "  Escribe el numero para marcar/desmarcar. 'a' para todas. 'ok' para continuar."
        echo ""

        for ((i=0; i<count; i++)); do
            local entry="${items[$i]}"
            local vm_name="${entry%%|*}"
            local rest="${entry#*|}"
            local tipo="${rest%%|*}"
            local estado="${rest#*|}"

            local marca=" "
            [[ "${checks[$i]}" == "on" ]] && marca="x"

            # Obtener tamaño del disco
            local disco_info=""
            local conn
            if [[ "$tipo" == "sesion" ]]; then
                conn="qemu:///session"
                local disco_path
                disco_path=$(virsh -c "$conn" dumpxml "$vm_name" 2>/dev/null | grep -oP "source file='\K[^']+" | head -1 || true)
                if [[ -n "$disco_path" && -f "$disco_path" ]]; then
                    disco_info=$(du -h "$disco_path" 2>/dev/null | cut -f1)
                fi
            else
                conn="qemu:///system"
                local disco_path
                disco_path=$(sudo virsh -c "$conn" dumpxml "$vm_name" 2>/dev/null | grep -oP "source file='\K[^']+" | head -1 || true)
                if [[ -n "$disco_path" ]]; then
                    disco_info=$(sudo du -h "$disco_path" 2>/dev/null | cut -f1)
                fi
            fi

            local size_str=""
            [[ -n "$disco_info" ]] && size_str=" - ${disco_info}"

            echo -e "  ${CYAN}[$marca]${NC} $((i+1)). $vm_name  (${tipo}, ${estado}${size_str})"
        done

        echo ""
        echo -n "  > "
        read -r input

        case "$input" in
            ok|OK|Ok)
                # Recopilar seleccionadas
                selected=()
                for ((i=0; i<count; i++)); do
                    if [[ "${checks[$i]}" == "on" ]]; then
                        selected+=("${items[$i]}")
                    fi
                done
                if [[ ${#selected[@]} -eq 0 ]]; then
                    echo ""
                    warn "No seleccionaste ninguna VM"
                    read -rp "  Presiona Enter para volver..."
                    continue
                fi
                return 0
                ;;
            a|A)
                local all_on=true
                for ((i=0; i<count; i++)); do
                    [[ "${checks[$i]}" == "on" ]] || { all_on=false; break; }
                done
                for ((i=0; i<count; i++)); do
                    if $all_on; then checks[$i]="off"; else checks[$i]="on"; fi
                done
                ;;
            q|Q|salir)
                echo ""
                msg "Cancelado"
                exit 0
                ;;
            *)
                if [[ "$input" =~ ^[0-9]+$ ]] && ((input >= 1 && input <= count)); then
                    local idx=$((input - 1))
                    if [[ "${checks[$idx]}" == "on" ]]; then
                        checks[$idx]="off"
                    else
                        checks[$idx]="on"
                    fi
                fi
                ;;
        esac
    done
}

export_single_vm() {
    local vm_name="$1"
    local tipo="$2"
    local dest="$3"

    local conn
    [[ "$tipo" == "sesion" ]] && conn="qemu:///session" || conn="qemu:///system"

    echo -e "${CYAN}--- Exportando: $vm_name ---${NC}"

    # Crear carpeta
    local vm_dest="$dest/$vm_name"
    mkdir -p "$vm_dest"

    # Exportar XML
    if [[ "$conn" == "qemu:///system" ]]; then
        sudo virsh -c "$conn" dumpxml "$vm_name" > "$vm_dest/$vm_name.xml" 2>/dev/null
    else
        virsh -c "$conn" dumpxml "$vm_name" > "$vm_dest/$vm_name.xml" 2>/dev/null
    fi
    msg "XML exportado"

    # Extraer y copiar discos
    local discos
    discos=$(grep -oP "source file='\K[^']+" "$vm_dest/$vm_name.xml" || true)

    if [[ -n "$discos" ]]; then
        while IFS= read -r disco; do
            local nombre_disco
            nombre_disco=$(basename "$disco")

            if [[ -r "$disco" ]]; then
                local disco_size
                disco_size=$(du -h "$disco" | cut -f1)
                warn "Copiando $nombre_disco ($disco_size)..."
                rsync --progress "$disco" "$vm_dest/$nombre_disco"
                msg "$nombre_disco copiado"
            elif sudo test -r "$disco"; then
                local disco_size
                disco_size=$(sudo du -h "$disco" | cut -f1)
                warn "Copiando $nombre_disco ($disco_size) (sudo)..."
                sudo rsync --progress "$disco" "$vm_dest/$nombre_disco"
                sudo chown "$(id -un):$(id -gn)" "$vm_dest/$nombre_disco"
                msg "$nombre_disco copiado"
            else
                warn "No se puede leer $disco, saltando"
            fi
        done <<< "$discos"
    else
        warn "No se encontraron discos"
    fi

    # Copiar NVRAM si existe
    local nvram_path
    nvram_path=$(grep -oP '<nvram[^>]*>\K[^<]+' "$vm_dest/$vm_name.xml" || true)
    if [[ -n "$nvram_path" ]]; then
        if [[ -r "$nvram_path" ]]; then
            cp "$nvram_path" "$vm_dest/$(basename "$nvram_path")"
            msg "NVRAM copiado"
        elif sudo test -r "$nvram_path" 2>/dev/null; then
            sudo cp "$nvram_path" "$vm_dest/$(basename "$nvram_path")"
            sudo chown "$(id -un):$(id -gn)" "$vm_dest/$(basename "$nvram_path")"
            msg "NVRAM copiado (sudo)"
        else
            warn "NVRAM no encontrado (se regenerara al importar)"
        fi
    fi

    msg "'$vm_name' exportada"
    echo ""
}

do_export() {
    local dest="${1:?Falta destino. Uso: $0 export /media/usb}"
    dest="${dest%/}"

    [[ -d "$dest" ]] || err "El destino '$dest' no existe"

    # Recopilar VMs
    local all_vms=()
    gather_all_vms all_vms

    [[ ${#all_vms[@]} -gt 0 ]] || err "No se encontraron VMs en el sistema"

    # Seleccion interactiva
    local selected_vms=()
    select_vms all_vms selected_vms

    echo ""
    echo -e "${BOLD}=== EXPORTANDO ${#selected_vms[@]} VM(s) ===${NC}"
    echo ""

    for entry in "${selected_vms[@]}"; do
        local vm_name="${entry%%|*}"
        local rest="${entry#*|}"
        local tipo="${rest%%|*}"
        export_single_vm "$vm_name" "$tipo" "$dest"
    done

    # Copiar script
    cp "$0" "$dest/migrate-vm.sh" 2>/dev/null && chmod +x "$dest/migrate-vm.sh"

    echo "=== Resumen ==="
    echo ""
    for entry in "${selected_vms[@]}"; do
        local vm_name="${entry%%|*}"
        msg "$vm_name"
        ls -lh "$dest/$vm_name/" 2>/dev/null | grep -v "^total"
        echo ""
    done
    echo "En Fedora ejecuta:"
    echo "  ./migrate-vm.sh import $dest"
}

do_import() {
    local origen="${1:?Falta origen. Uso: $0 import /media/usb}"
    origen="${origen%/}"

    [[ -d "$origen" ]] || err "El origen '$origen' no existe"

    echo ""
    echo "=== IMPORTAR VMs en GNOME Boxes ==="
    echo ""

    # Verificar e instalar dependencias
    install_deps
    echo ""

    # Buscar VMs exportadas (carpetas con .xml)
    local available_vms=()
    for dir in "$origen"/*/; do
        [[ -d "$dir" ]] || continue
        local xml_file
        xml_file=$(find "$dir" -maxdepth 1 -name "*.xml" 2>/dev/null | head -1)
        [[ -n "$xml_file" ]] || continue

        local vm_name
        vm_name=$(grep -oP '<name>\K[^<]+' "$xml_file" 2>/dev/null || basename "$dir")

        local disco_size=""
        local disco_file
        disco_file=$(find "$dir" -maxdepth 1 \( -name "*.qcow2" -o -name "*.raw" -o -name "*.vmdk" -o -name "*.vdi" \) 2>/dev/null | head -1)
        [[ -n "$disco_file" ]] && disco_size=$(du -h "$disco_file" 2>/dev/null | cut -f1)

        available_vms+=("$vm_name|${dir%/}|${disco_size:-?}")
    done

    [[ ${#available_vms[@]} -gt 0 ]] || err "No se encontraron VMs en '$origen'"

    # Seleccion interactiva
    local count=${#available_vms[@]}
    local checks=()
    for ((i=0; i<count; i++)); do checks+=("off"); done

    while true; do
        clear
        echo ""
        echo -e "${BOLD}=== VMs disponibles para importar ===${NC}"
        echo ""
        echo "  Escribe el numero para marcar/desmarcar. 'a' para todas. 'ok' para continuar."
        echo ""

        for ((i=0; i<count; i++)); do
            local entry="${available_vms[$i]}"
            local vm_name="${entry%%|*}"
            local rest="${entry#*|}"
            local vm_dir="${rest%%|*}"
            local size="${rest##*|}"

            local marca=" "
            [[ "${checks[$i]}" == "on" ]] && marca="x"

            echo -e "  ${CYAN}[$marca]${NC} $((i+1)). $vm_name  (${size})"
        done

        echo ""
        echo -n "  > "
        read -r input

        case "$input" in
            ok|OK|Ok)
                local any_selected=false
                for ((i=0; i<count; i++)); do
                    [[ "${checks[$i]}" == "on" ]] && { any_selected=true; break; }
                done
                if ! $any_selected; then
                    warn "No seleccionaste ninguna VM"
                    read -rp "  Presiona Enter para volver..."
                    continue
                fi
                break
                ;;
            a|A)
                local all_on=true
                for ((i=0; i<count; i++)); do
                    [[ "${checks[$i]}" == "on" ]] || { all_on=false; break; }
                done
                for ((i=0; i<count; i++)); do
                    if $all_on; then checks[$i]="off"; else checks[$i]="on"; fi
                done
                ;;
            q|Q|salir)
                msg "Cancelado"
                exit 0
                ;;
            *)
                if [[ "$input" =~ ^[0-9]+$ ]] && ((input >= 1 && input <= count)); then
                    local idx=$((input - 1))
                    if [[ "${checks[$idx]}" == "on" ]]; then checks[$idx]="off"; else checks[$idx]="on"; fi
                fi
                ;;
        esac
    done

    echo ""

    local vm_dir_dest="$HOME/VMs"
    local nvram_dir="$HOME/.local/share/libvirt/qemu/nvram"
    mkdir -p "$vm_dir_dest" "$nvram_dir"

    for ((i=0; i<count; i++)); do
        [[ "${checks[$i]}" == "on" ]] || continue

        local entry="${available_vms[$i]}"
        local vm_name="${entry%%|*}"
        local rest="${entry#*|}"
        local vdir="${rest%%|*}"

        echo -e "${CYAN}--- Importando: $vm_name ---${NC}"
        echo ""

        local xml_file
        xml_file=$(find "$vdir" -maxdepth 1 -name "*.xml" | head -1)

        # Copiar discos
        local disco_archivos
        disco_archivos=$(find "$vdir" -maxdepth 1 \( -name "*.qcow2" -o -name "*.raw" -o -name "*.qed" -o -name "*.vmdk" -o -name "*.vdi" \) 2>/dev/null || true)

        if [[ -n "$disco_archivos" ]]; then
            while IFS= read -r disco; do
                local nombre
                nombre=$(basename "$disco")
                if [[ -f "$vm_dir_dest/$nombre" ]]; then
                    warn "Ya existe $vm_dir_dest/$nombre"
                    read -rp "     Sobreescribir? [s/N]: " resp
                    [[ "$resp" =~ ^[sS]$ ]] || continue
                fi
                local disco_size
                disco_size=$(du -h "$disco" | cut -f1)
                warn "Copiando $nombre ($disco_size)..."
                rsync --progress "$disco" "$vm_dir_dest/$nombre"
                msg "$nombre copiado"
            done <<< "$disco_archivos"
        fi

        # Copiar NVRAM
        local nvram_archivos
        nvram_archivos=$(find "$vdir" -maxdepth 1 \( -name "*VARS*" -o -name "*nvram*" \) ! -name "*.xml" 2>/dev/null | head -1 || true)
        if [[ -n "$nvram_archivos" ]]; then
            local nvram_nombre
            nvram_nombre=$(basename "$nvram_archivos")
            cp "$nvram_archivos" "$nvram_dir/$nvram_nombre"
            msg "NVRAM copiado"
        fi

        # Adaptar XML
        local xml_tmp="/tmp/${vm_name}-import.xml"
        cp "$xml_file" "$xml_tmp"

        # Reemplazar rutas de discos
        if [[ -n "$disco_archivos" ]]; then
            while IFS= read -r disco; do
                local nombre
                nombre=$(basename "$disco")
                sed -i "s|<source file='[^']*${nombre}'/>|<source file='${vm_dir_dest}/${nombre}'/>|g" "$xml_tmp"
            done <<< "$disco_archivos"
        fi

        # Reemplazar NVRAM
        if [[ -n "$nvram_archivos" ]]; then
            local nvram_nombre
            nvram_nombre=$(basename "$nvram_archivos")
            sed -i "s|<nvram[^>]*>[^<]*</nvram>|<nvram template='/usr/share/OVMF/OVMF_VARS_4M.ms.fd' templateFormat='raw' format='raw'>${nvram_dir}/${nvram_nombre}</nvram>|" "$xml_tmp"
        fi

        # Adaptar rutas OVMF para la distro actual
        local ovmf_code="" ovmf_vars=""
        for candidate in \
            "/usr/share/OVMF/OVMF_CODE_4M.ms.fd" \
            "/usr/share/edk2/ovmf/OVMF_CODE.secboot.fd" \
            "/usr/share/edk2/x64/OVMF_CODE.secboot.4m.fd" \
            "/usr/share/qemu/OVMF_CODE_4M.ms.fd" \
            "/usr/share/OVMF/x64/OVMF_CODE.secboot.4m.fd"; do
            if [[ -f "$candidate" ]]; then
                ovmf_code="$candidate"
                ovmf_vars="${candidate/CODE/VARS}"
                break
            fi
        done
        if [[ -n "$ovmf_code" ]]; then
            sed -i \
                -e "s|<loader[^>]*>[^<]*</loader>|<loader readonly='yes' secure='yes' type='pflash' format='raw'>$ovmf_code</loader>|" \
                "$xml_tmp"
            # Actualizar template del nvram
            sed -i "s|template='[^']*OVMF_VARS[^']*'|template='$ovmf_vars'|g" "$xml_tmp"
            msg "Rutas OVMF adaptadas ($(detect_distro))"
        fi

        # Red: network -> user
        if grep -q "type='network'" "$xml_tmp"; then
            sed -i "s|<interface type='network'>|<interface type='user'>|g" "$xml_tmp"
            sed -i "/<source network=/d" "$xml_tmp"
            msg "Red adaptada a modo usuario"
        fi

        # Limpiar UUID, evmcs, avic
        sed -i "/<uuid>/d; /<evmcs /d; /<avic /d" "$xml_tmp"

        # Definir
        if virsh -c qemu:///session dominfo "$vm_name" &>/dev/null; then
            warn "Ya existe '$vm_name'"
            read -rp "     Reemplazar? [s/N]: " resp
            if [[ "$resp" =~ ^[sS]$ ]]; then
                virsh -c qemu:///session undefine "$vm_name" --nvram 2>/dev/null || \
                virsh -c qemu:///session undefine "$vm_name" 2>/dev/null
            else
                warn "Saltando $vm_name"
                echo ""
                continue
            fi
        fi

        virsh -c qemu:///session define "$xml_tmp" 2>&1
        msg "'$vm_name' importada"
        echo ""
    done

    echo "=== VMs en GNOME Boxes ==="
    virsh -c qemu:///session list --all
    echo ""
    msg "Importacion completa! Abre GNOME Boxes."
}

# Main
cmd="${1:-}"
arg="${2:-}"
case "$cmd" in
    export) do_export "$arg" ;;
    import) do_import "$arg" ;;
    setup)  install_deps ;;
    *)      usage ;;
esac
