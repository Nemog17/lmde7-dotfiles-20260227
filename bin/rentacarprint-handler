#!/usr/bin/env bash
set -euo pipefail

URI="${1:-}"
PRINTER="${RENTACAR_PRINTER:-DATECS_DPP350_TEXT}"
STAMP_FILE="/tmp/rentacarprint.laststamp"
HASH_FILE="/tmp/rentacarprint.lasthash"
BT_MAC="${RENTACAR_BT_MAC:-68:AA:D2:12:2B:DC}"

if [[ "$URI" == rentacarprint://reset* ]]; then
  if command -v bluetoothctl >/dev/null 2>&1; then
    bluetoothctl trust "$BT_MAC" >/dev/null 2>&1 || true
  fi

  RESET_FILE="$(mktemp /tmp/rentacarprint.reset.XXXXXX.bin)"
  trap 'rm -f "$RESET_FILE"' EXIT

  # Generic normalization for ESC/POS-compatible mode.
  python3 - "$RESET_FILE" <<'PY'
import sys

output_path = sys.argv[1]
payload = (
    b"\x1b@"        # ESC @ initialize
    b"\x1b\x74\x00" # ESC t 0 -> code table 437/US
    b"\x1b\x3e\x01" # ESC > 1 -> force left-to-right direction
    b"\x1d\x42\x00" # GS B 0 reverse off
    b"\x1b\x7b\x00" # ESC { 0 upside-down off
    b"\x1b\x61\x00" # ESC a 0 align left
    b"\n"
)
with open(output_path, "wb") as f:
    f.write(payload)
PY

  if lp -d "$PRINTER" -o raw "$RESET_FILE" >/tmp/rentacarprint.lastjob 2>/tmp/rentacarprint.lasterr; then
    notify-send "RentaCar Print" "Reset de modo enviado a $PRINTER" || true
    exit 0
  fi

  ERR_MSG="$(cat /tmp/rentacarprint.lasterr 2>/dev/null || true)"
  notify-send "RentaCar Print" "Error en reset: ${ERR_MSG:-fallo de lp}" || true
  exit 1
fi

if [[ -z "$URI" ]]; then
  notify-send "RentaCar Print" "No se recibio URI de impresion" || true
  exit 1
fi

# Parse custom URI: rentacarprint://print?data=<base64url>
DECODED_TEXT="$(python3 - "$URI" <<'PY'
import base64
import sys
from urllib.parse import urlparse, parse_qs

uri = sys.argv[1]
parts = urlparse(uri)
qs = parse_qs(parts.query)
data = qs.get('data', [''])[0]
if not data:
    sys.exit(2)

# URL-safe base64 decode with padding
pad = '=' * ((4 - len(data) % 4) % 4)
raw = base64.urlsafe_b64decode((data + pad).encode('ascii'))
text = raw.decode('utf-8', errors='replace')
print(text, end='')
PY
)" || {
  notify-send "RentaCar Print" "No se pudo decodificar ticket" || true
  exit 1
}

if [[ -z "$DECODED_TEXT" ]]; then
  notify-send "RentaCar Print" "Ticket vacio" || true
  exit 1
fi

NOW_TS="$(date +%s)"
NOW_HASH="$(printf '%s' "$DECODED_TEXT" | sha256sum | awk '{print $1}')"
if [[ -f "$STAMP_FILE" ]]; then
  LAST_TS="$(cat "$STAMP_FILE" 2>/dev/null || echo 0)"
  LAST_HASH="$(cat "$HASH_FILE" 2>/dev/null || true)"
  if [[ "$LAST_TS" =~ ^[0-9]+$ ]] && (( NOW_TS - LAST_TS < 4 )) && [[ "$NOW_HASH" == "$LAST_HASH" ]]; then
    notify-send "RentaCar Print" "Ignorado: ticket duplicado en pocos segundos" || true
    exit 0
  fi
fi
echo "$NOW_TS" > "$STAMP_FILE"
echo "$NOW_HASH" > "$HASH_FILE"

# Ensure device stays trusted; do not force bluetoothctl connect for SPP printers
# because many expose Serial Port only and return profile-unavailable outside
# the actual print backend flow.
if command -v bluetoothctl >/dev/null 2>&1; then
  bluetoothctl trust "$BT_MAC" >/dev/null 2>&1 || true
fi

PAYLOAD_FILE="$(mktemp /tmp/rentacarprint.XXXXXX.txt)"
trap 'rm -f "$PAYLOAD_FILE"' EXIT

# Build one raw ESC/POS payload so direction and code table are forced per job.
python3 - "$PAYLOAD_FILE" "$DECODED_TEXT" <<'PY'
import sys

output_path = sys.argv[1]
ticket_text = sys.argv[2]

normalized = ticket_text.replace("\r\n", "\n").replace("\r", "\n")
ascii_text = normalized.encode("ascii", errors="replace").decode("ascii")

payload = (
    b"\x1b@"        # ESC @ initialize
    b"\x1b\x74\x00" # ESC t 0 -> code table 437/US
    b"\x1b\x3e\x01" # ESC > 1 -> force left-to-right direction
    b"\x1d\x42\x00" # GS B 0 reverse off
    b"\x1b\x7b\x00" # ESC { 0 upside-down off
    b"\x1b\x61\x00" # ESC a 0 align left
    + ascii_text.encode("ascii", errors="replace")
    + b"\r\n\r\n\r\n"
)

with open(output_path, "wb") as f:
    f.write(payload)
PY

if lp -d "$PRINTER" -o raw "$PAYLOAD_FILE" >/tmp/rentacarprint.lastjob 2>/tmp/rentacarprint.lasterr; then
  notify-send "RentaCar Print" "Ticket enviado a $PRINTER" || true
  exit 0
fi

ERR_MSG="$(cat /tmp/rentacarprint.lasterr 2>/dev/null || true)"
notify-send "RentaCar Print" "Error al imprimir: ${ERR_MSG:-fallo de lp}" || true
exit 1
